From 8e4f61d761fb9e4c6f49342184818df6749892ba Mon Sep 17 00:00:00 2001
From: David Li <dl3466@nyu.edu>
Date: Sun, 14 Apr 2019 20:16:53 -0400
Subject: [PATCH] Implement scheduling algorithms

---
 Makefile  |  13 +-
 defs.h    |   1 +
 param.h   |   2 +-
 proc.c    | 628 ++++++++++++++++++++++++++++++++++++++----------------
 proc.h    |  10 +-
 sanity.c  |  49 +++++
 syscall.c |   4 +-
 syscall.h |   1 +
 sysproc.c |  24 ++-
 trap.c    |  29 ++-
 user.h    |   1 +
 usys.S    |   1 +
 12 files changed, 568 insertions(+), 195 deletions(-)
 create mode 100644 sanity.c

diff --git a/Makefile b/Makefile
index b4fd9a2..11c3fcf 100644
--- a/Makefile
+++ b/Makefile
@@ -32,7 +32,7 @@ OBJS = \
 # TOOLPREFIX = i386-jos-elf
 
 # Using native tools (e.g., on X86 Linux)
-#TOOLPREFIX = 
+#TOOLPREFIX =
 
 # Try to infer the correct TOOLPREFIX if not set
 ifndef TOOLPREFIX
@@ -75,12 +75,16 @@ LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer -D $(SCHEDFLAG)
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
 LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
 
+ifndef SCHEDFLAG
+SCHEDFLAG := DEFAULT
+endif
+
 xv6.img: bootblock kernel fs.img
 	dd if=/dev/zero of=xv6.img count=10000
 	dd if=bootblock of=xv6.img conv=notrunc
@@ -172,13 +176,14 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_sanity\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
 
 -include *.d
 
-clean: 
+clean:
 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
 	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
@@ -210,7 +215,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 ifndef CPUS
 CPUS := 2
 endif
-QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)
+QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA) -display none
 
 qemu: fs.img xv6.img
 	$(QEMU) -serial mon:stdio $(QEMUOPTS)
diff --git a/defs.h b/defs.h
index b47372b..ed32e2c 100644
--- a/defs.h
+++ b/defs.h
@@ -118,6 +118,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int            wait_stat(int *wtime, int *rtime, int *iotime, int* status);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/param.h b/param.h
index a7e90ef..d0db235 100644
--- a/param.h
+++ b/param.h
@@ -11,4 +11,4 @@
 #define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
-
+#define QUANTA       5
diff --git a/proc.c b/proc.c
index fee4e95..a4e8415 100644
--- a/proc.c
+++ b/proc.c
@@ -12,6 +12,45 @@ struct {
   struct proc proc[NPROC];
 } ptable;
 
+// Definition of the process queue
+struct queue {
+	struct proc* queue[NPROC]; //Array where the processes will be stored
+	struct spinlock lock; //lock for the queue
+	int size; // Number of processes in queue
+  int front, rear; //First and last element in queue and
+};
+
+struct queue queue;
+
+// Queue initialization function
+void queue_init(struct queue *q)
+{
+  //empty queue on init so size is zero and front and rear are 0 because no elements
+  q->size = 0;
+  q->front = 0;
+  q->rear = 0;
+  initlock(&q->lock, "proc_queue");
+}
+
+// Queue enqueue function
+void enqueue( struct queue * queue, struct proc *item )
+{
+  // The process is placed where the rear of the queue is pointing
+  queue->queue[queue->rear] = item;
+  // update the location of the rear using modulo because using array and not linked list
+  queue->rear = (queue->rear + 1)%NPROC;
+  (queue->size)++;
+}
+
+// Queue dequeue function
+struct proc *dequeue(struct queue *queue)
+{
+  struct proc* item = queue->queue[queue->front];
+  queue->front = (queue->front + 1 )%NPROC;
+  (queue->size)--;
+  return item;
+}
+
 static struct proc *initproc;
 
 int nextpid = 1;
@@ -20,10 +59,18 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
+void scheduler_default(void) __attribute__((noreturn));
+void scheduler_frr(void) __attribute__((noreturn));
+void scheduler_fcfs(void) __attribute__((noreturn));
+
 void
 pinit(void)
 {
   initlock(&ptable.lock, "ptable");
+  // initialize the queue as well
+  #ifndef DEFAULT
+  queue_init(&queue);
+  #endif
 }
 
 //PAGEBREAK: 32
@@ -41,65 +88,81 @@ allocproc(void)
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
     if(p->state == UNUSED)
       goto found;
-  release(&ptable.lock);
-  return 0;
+    release(&ptable.lock);
+    return 0;
 
-found:
-  p->state = EMBRYO;
-  p->pid = nextpid++;
-  release(&ptable.lock);
+    found:
+    p->state = EMBRYO;
+    p->pid = nextpid++;
+    release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
-    p->state = UNUSED;
-    return 0;
-  }
-  sp = p->kstack + KSTACKSIZE;
-  
+    if((p->kstack = kalloc()) == 0){
+      p->state = UNUSED;
+      return 0;
+    }
+    sp = p->kstack + KSTACKSIZE;
+
   // Leave room for trap frame.
-  sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
-  
+    sp -= sizeof *p->tf;
+    p->tf = (struct trapframe*)sp;
+
   // Set up new context to start executing at forkret,
   // which returns to trapret.
-  sp -= 4;
-  *(uint*)sp = (uint)trapret;
-
-  sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
-  memset(p->context, 0, sizeof *p->context);
-  p->context->eip = (uint)forkret;
-
-  return p;
-}
+    sp -= 4;
+    *(uint*)sp = (uint)trapret;
+
+    sp -= sizeof *p->context;
+    p->context = (struct context*)sp;
+    memset(p->context, 0, sizeof *p->context);
+    p->context->eip = (uint)forkret;
+
+    //initialize time values for the process
+    p->ctime = ticks; //create is current ticks rest are zeros because no values rn
+    p->ttime = 0;
+    p->stime = 0;
+    p->retime = 0;
+    p->rutime = 0;
+
+    //put the process in the scheduling queue
+    #ifndef DEFAULT
+  	acquire(&queue.lock);
+  	enqueue(&queue, p);
+  	release(&queue.lock);
+  	#endif
+
+    return p;
+  }
 
 //PAGEBREAK: 32
 // Set up first user process.
-void
-userinit(void)
-{
-  struct proc *p;
-  extern char _binary_initcode_start[], _binary_initcode_size[];
-  
-  p = allocproc();
-  initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
-    panic("userinit: out of memory?");
-  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
-  p->sz = PGSIZE;
-  memset(p->tf, 0, sizeof(*p->tf));
-  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
-  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
-  p->tf->es = p->tf->ds;
-  p->tf->ss = p->tf->ds;
-  p->tf->eflags = FL_IF;
-  p->tf->esp = PGSIZE;
+  void
+  userinit(void)
+  {
+    struct proc *p;
+    extern char _binary_initcode_start[], _binary_initcode_size[];
+
+    p = allocproc();
+    initproc = p;
+    if((p->pgdir = setupkvm()) == 0)
+      panic("userinit: out of memory?");
+    inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+    p->sz = PGSIZE;
+    memset(p->tf, 0, sizeof(*p->tf));
+    p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+    p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+    p->tf->es = p->tf->ds;
+    p->tf->ss = p->tf->ds;
+    p->tf->eflags = FL_IF;
+    p->tf->esp = PGSIZE;
   p->tf->eip = 0;  // beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
-
   p->state = RUNNABLE;
+  #ifndef DEFAULT
+  enqueue(&queue,p);
+  #endif
 }
 
 // Grow current process's memory by n bytes.
@@ -108,7 +171,7 @@ int
 growproc(int n)
 {
   uint sz;
-  
+
   sz = proc->sz;
   if(n > 0){
     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
@@ -152,102 +215,105 @@ fork(void)
   for(i = 0; i < NOFILE; i++)
     if(proc->ofile[i])
       np->ofile[i] = filedup(proc->ofile[i]);
-  np->cwd = idup(proc->cwd);
+    np->cwd = idup(proc->cwd);
+
+    safestrcpy(np->name, proc->name, sizeof(proc->name));
 
-  safestrcpy(np->name, proc->name, sizeof(proc->name));
- 
-  pid = np->pid;
+    pid = np->pid;
 
   // lock to force the compiler to emit the np->state write last.
-  acquire(&ptable.lock);
-  np->state = RUNNABLE;
-  release(&ptable.lock);
-  
-  return pid;
-}
+    acquire(&ptable.lock);
+    np->state = RUNNABLE;
+    #ifndef DEFAULT
+    enqueue(&queue,np);
+    #endif
+    release(&ptable.lock);
+
+    return pid;
+  }
 
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
-{
-  struct proc *p;
-  int fd;
+  void
+  exit(void)
+  {
+    struct proc *p;
+    int fd;
 
-  if(proc == initproc)
-    panic("init exiting");
+    if(proc == initproc)
+      panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(proc->ofile[fd]){
-      fileclose(proc->ofile[fd]);
-      proc->ofile[fd] = 0;
+    for(fd = 0; fd < NOFILE; fd++){
+      if(proc->ofile[fd]){
+        fileclose(proc->ofile[fd]);
+        proc->ofile[fd] = 0;
+      }
     }
-  }
 
-  begin_op();
-  iput(proc->cwd);
-  end_op();
-  proc->cwd = 0;
+    begin_op();
+    iput(proc->cwd);
+    end_op();
+    proc->cwd = 0;
 
-  acquire(&ptable.lock);
+    acquire(&ptable.lock);
 
   // Parent might be sleeping in wait().
-  wakeup1(proc->parent);
+    wakeup1(proc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == proc){
-      p->parent = initproc;
-      if(p->state == ZOMBIE)
-        wakeup1(initproc);
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent == proc){
+        p->parent = initproc;
+        if(p->state == ZOMBIE)
+          wakeup1(initproc);
+      }
     }
-  }
 
   // Jump into the scheduler, never to return.
-  proc->state = ZOMBIE;
-  sched();
-  panic("zombie exit");
-}
+    proc->state = ZOMBIE;
+    sched();
+    panic("zombie exit");
+  }
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
-{
-  struct proc *p;
-  int havekids, pid;
+  int
+  wait(void)
+  {
+    struct proc *p;
+    int havekids, pid;
 
-  acquire(&ptable.lock);
-  for(;;){
+    acquire(&ptable.lock);
+    for(;;){
     // Scan through table looking for zombie children.
-    havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != proc)
-        continue;
-      havekids = 1;
-      if(p->state == ZOMBIE){
+      havekids = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+        if(p->parent != proc)
+          continue;
+        havekids = 1;
+        if(p->state == ZOMBIE){
         // Found one.
-        pid = p->pid;
-        kfree(p->kstack);
-        p->kstack = 0;
-        freevm(p->pgdir);
-        p->state = UNUSED;
-        p->pid = 0;
-        p->parent = 0;
-        p->name[0] = 0;
-        p->killed = 0;
-        release(&ptable.lock);
-        return pid;
+          pid = p->pid;
+          kfree(p->kstack);
+          p->kstack = 0;
+          freevm(p->pgdir);
+          p->state = UNUSED;
+          p->pid = 0;
+          p->parent = 0;
+          p->name[0] = 0;
+          p->killed = 0;
+          release(&ptable.lock);
+          return pid;
+        }
       }
-    }
 
     // No point waiting if we don't have any children.
-    if(!havekids || proc->killed){
-      release(&ptable.lock);
-      return -1;
-    }
+      if(!havekids || proc->killed){
+        release(&ptable.lock);
+        return -1;
+      }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
     sleep(proc, &ptable.lock);  //DOC: wait-sleep
@@ -264,43 +330,176 @@ wait(void)
 //      via swtch back to the scheduler.
 void
 scheduler(void)
+{
+  #ifdef DEFAULT
+		scheduler_default();
+	#else
+	#ifdef FRR
+		scheduler_frr();
+	#else
+	#ifdef FCFS
+		scheduler_fcfs();
+	#endif
+	#endif
+	#endif
+}
+
+void scheduler_default(void)
 {
   struct proc *p;
   int foundproc = 1;
 
-  for(;;){
+  for (; ;) {
     // Enable interrupts on this processor.
     sti();
 
     if (!foundproc) hlt();
 
     foundproc = 0;
-
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->state != RUNNABLE)
         continue;
 
+      foundproc = 1;
+
+      starttick=ticks;
+      endtick=ticks;
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
-      foundproc = 1;
       proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-      swtch(&cpu->scheduler, proc->context);
-      switchkvm();
+      while (endtick-starttick <= QUANTA)
+      {
+        switchuvm(p);
+        p->state = RUNNING;
+        swtch(&cpu->scheduler, proc->context);
+        switchkvm();
+        if (proc->state != RUNNABLE)
+          break;
+      }
 
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       proc = 0;
     }
     release(&ptable.lock);
-
   }
 }
 
+void scheduler_frr(void) {
+	// Switch from current process if it's run for QUANTA cycles,
+	// put it at end of queue, switch to process at start of queue
+	struct proc *p;
+	int foundproc = 1;
+
+	for(;;) {
+		// Enable interrupts on this processor.
+		sti();
+
+		if (!foundproc) hlt();
+
+		foundproc = 0;
+			// Loop over process table looking for process to run.
+		acquire(&ptable.lock);
+
+		acquire(&queue.lock);
+		if (queue.size == 0) {
+			for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+				if (p->state == RUNNABLE) {
+					enqueue(&queue, p);
+				}
+			}
+		}
+		release(&queue.lock);
+
+
+		while (queue.size > 0) {
+			acquire(&queue.lock);
+			p = dequeue(&queue);
+			release(&queue.lock);
+			if (p->state == RUNNABLE) {
+				starttick = ticks;
+				endtick = ticks;
+
+				foundproc = 1;
+
+				proc = p;
+				while (endtick - starttick <= QUANTA) {
+					switchuvm(p);
+					p->state = RUNNING;
+					swtch(&cpu->scheduler, proc->context);
+					switchkvm();
+					if (proc->state != RUNNING) {
+						break;
+					}
+				}
+
+				if (proc->state == RUNNABLE) {
+					acquire(&queue.lock);
+					enqueue(&queue, proc);
+					release(&queue.lock);
+				}
+
+				proc = 0;
+			}
+		}
+		release(&ptable.lock);
+	}
+}
+
+void scheduler_fcfs(void) {
+	struct proc *p;
+	int foundproc = 1;
+
+	for(;;) {
+		// Enable interrupts on this processor.
+		sti();
+
+		if (!foundproc) hlt();
+
+		foundproc = 0;
+			// Loop over process table looking for process to run.
+		acquire(&ptable.lock);
+
+		acquire(&queue.lock);
+		if (queue.size == 0) {
+			for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+				if (p->state == RUNNABLE) {
+					enqueue(&queue, p);
+				}
+			}
+		}
+		release(&queue.lock);
+
+
+		while (queue.size > 0) {
+			acquire(&queue.lock);
+			p = dequeue(&queue);
+			release(&queue.lock);
+			if (p->state == RUNNABLE) {
+
+				foundproc = 1;
+
+				proc = p;
+				for(;;) {
+					switchuvm(p);
+					p->state = RUNNING;
+					swtch(&cpu->scheduler, proc->context);
+					switchkvm();
+					if (proc->state != RUNNING) {
+						break;
+					}
+				}
+
+				proc = 0;
+			}
+		}
+		release(&ptable.lock);
+	}
+}
+
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state.
 void
@@ -327,6 +526,9 @@ yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
   proc->state = RUNNABLE;
+  #ifndef DEFAULT
+  enqueue(&queue,proc);
+  #endif
   sched();
   release(&ptable.lock);
 }
@@ -342,13 +544,13 @@ forkret(void)
 
   if (first) {
     // Some initialization functions must be run in the context
-    // of a regular process (e.g., they call sleep), and thus cannot 
+    // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
     first = 0;
     iinit(ROOTDEV);
     initlog(ROOTDEV);
   }
-  
+
   // Return to "caller", actually trapret (see allocproc).
 }
 
@@ -398,75 +600,145 @@ wakeup1(void *chan)
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+    if(p->state == SLEEPING && p->chan == chan){
       p->state = RUNNABLE;
-}
+    }
+
+
+  }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
-{
-  acquire(&ptable.lock);
-  wakeup1(chan);
-  release(&ptable.lock);
-}
+  void
+  wakeup(void *chan)
+  {
+    acquire(&ptable.lock);
+    wakeup1(chan);
+    release(&ptable.lock);
+  }
 
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
-{
-  struct proc *p;
+  int
+  kill(int pid)
+  {
+    struct proc *p;
 
-  acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
-      p->killed = 1;
+    acquire(&ptable.lock);
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->pid == pid){
+        p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
-        p->state = RUNNABLE;
-      release(&ptable.lock);
-      return 0;
+        if(p->state == SLEEPING){
+          p->state = RUNNABLE;
+          #ifndef DEFAULT
+            //enq(&proc_queue,p);
+          #endif
+        }
+        release(&ptable.lock);
+        return 0;
+      }
     }
+    release(&ptable.lock);
+    return -1;
   }
-  release(&ptable.lock);
-  return -1;
-}
 
 //PAGEBREAK: 36
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
-{
-  static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
-  int i;
-  struct proc *p;
-  char *state;
-  uint pc[10];
-  
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
-      continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
-        cprintf(" %p", pc[i]);
+  void
+  procdump(void)
+  {
+    static char *states[] = {
+      [UNUSED]    "unused",
+      [EMBRYO]    "embryo",
+      [SLEEPING]  "sleep ",
+      [RUNNABLE]  "runble",
+      [RUNNING]   "run   ",
+      [ZOMBIE]    "zombie"
+    };
+    int i;
+    struct proc *p;
+    char *state;
+    uint pc[10];
+
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state == UNUSED)
+        continue;
+      if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+        state = states[p->state];
+      else
+        state = "???";
+      cprintf("%d %s %s", p->pid, state, p->name);
+      if(p->state == SLEEPING){
+        getcallerpcs((uint*)p->context->ebp+2, pc);
+        for(i=0; i<10 && pc[i] != 0; i++)
+          cprintf(" %p", pc[i]);
+      }
+      cprintf("\n");
+    }
+  }
+
+  int wait_stat(int *wtime, int *rtime, int *iotime, int *status)
+  {
+  struct proc *p;     //initalize  struct to use for the son procces
+  int havekids, pid;
+  acquire(&ptable.lock);
+
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+
+        *iotime = p->stime;
+        *rtime = p->rutime;
+        *wtime = p->retime;
+        *status = pid;
+        release(&ptable.lock);
+
+        return pid;
+      }
     }
-    cprintf("\n");
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
   }
 }
+
+void update_time(){
+  struct proc *p;
+
+  acquire(&ptable.lock);
+
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if (p->state == SLEEPING)
+      p->stime ++;
+    else if (p->state == RUNNABLE)
+      p->retime ++ ;
+    else if (p->state == RUNNING)
+      p->rutime ++;
+  }
+
+  release(&ptable.lock);
+}
diff --git a/proc.h b/proc.h
index 3b9c3ac..0ff05ef 100644
--- a/proc.h
+++ b/proc.h
@@ -10,7 +10,7 @@ struct cpu {
   volatile uint started;       // Has the CPU started?
   int ncli;                    // Depth of pushcli nesting.
   int intena;                  // Were interrupts enabled before pushcli?
-  
+
   // Cpu-local storage variables; see below
   struct cpu *cpu;
   struct proc *proc;           // The currently-running process.
@@ -19,6 +19,9 @@ struct cpu {
 extern struct cpu cpus[NCPU];
 extern int ncpu;
 
+void update_time();
+int endtick;
+int starttick;
 // Per-CPU variables, holding pointers to the
 // current cpu and to the current process.
 // The asm suffix tells gcc to use "%gs:0" to refer to cpu
@@ -66,6 +69,11 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  uint ctime;                  // creation time of a process
+  uint ttime;                  // termination time of a process
+  uint stime;                  // the time the process was sleeping
+  uint retime;                 // the time the process was ready
+  uint rutime;                 // the time the process was running
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/sanity.c b/sanity.c
new file mode 100644
index 0000000..1b90947
--- /dev/null
+++ b/sanity.c
@@ -0,0 +1,49 @@
+#include "types.h"
+#include "user.h"
+
+int main(int argc, char *argv[])
+{
+    int children_pid[20], exit_pid[20], pid, wAverage, rAverage, turnAroundAverage;
+    int create_index = 0;
+    int wait_index;
+
+    while (create_index < 20)
+    {
+        if ((pid = fork()) == 0){
+            break;
+        }
+        children_pid[create_index] = pid;
+        create_index++;
+    }
+
+    if ( pid != 0 )
+    {
+        wait_index = 0;
+        int wtime , rtime, iotime;
+        while ( wait_index < 20){
+            children_pid[wait_index] = wait_stat(&wtime,&rtime,&iotime,&(exit_pid[wait_index]));
+            printf(1, "child pid: %d \n", children_pid[wait_index]);
+            if (children_pid[wait_index] == exit_pid[wait_index]) {
+                printf(1, "Wait Time : %d , Running Time: %d , Turnaround Time: %d\n\n", wtime, rtime,wtime+rtime);
+            }
+
+            wAverage+= wtime;
+            rAverage+= rtime;
+            turnAroundAverage+= (wtime+rtime);
+            wait_index++;
+        }
+
+        printf(1,"Averages: \nAverage Wait Time: %d , Average Run Time: %d , Average Turnaround  Time %d \n", wAverage/20, rAverage/20, turnAroundAverage/20);
+        exit();
+    }
+    else {
+        int count = 0;
+        int num = 1;
+        while ( count < 50000000 )
+        {
+            count++;
+            num *= 2;
+        }
+        exit();
+    }
+}
diff --git a/syscall.c b/syscall.c
index 799ebc2..6859841 100644
--- a/syscall.c
+++ b/syscall.c
@@ -55,7 +55,7 @@ int
 argptr(int n, char **pp, int size)
 {
   int i;
-  
+
   if(argint(n, &i) < 0)
     return -1;
   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
@@ -98,6 +98,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_wait_stat(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +122,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_wait_stat] sys_wait_stat,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..20adbc3 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_wait_stat 22
diff --git a/sysproc.c b/sysproc.c
index 027a5e5..6220e21 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -61,7 +61,7 @@ sys_sleep(void)
 {
   int n;
   uint ticks0;
-  
+
   if(argint(0, &n) < 0)
     return -1;
   acquire(&tickslock);
@@ -83,9 +83,29 @@ int
 sys_uptime(void)
 {
   uint xticks;
-  
+
   acquire(&tickslock);
   xticks = ticks;
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_wait_stat(void)
+{
+  int *wtime;
+  int *iotime;
+  int *rtime;
+  int *status;
+
+  if (argptr(0,(char **) &wtime, sizeof(wtime)) < 0)
+    return -1;
+  if (argptr(1,(char **) &rtime, sizeof(rtime)) < 0)
+    return -1;
+  if (argptr(2,(char **) &iotime, sizeof(iotime)) < 0)
+    return -1;
+  if (argptr(3,(char **) &status, sizeof(status)) < 0)
+    return -1;
+
+  return wait_stat(wtime,rtime,iotime,status);
+}
diff --git a/trap.c b/trap.c
index 3f80145..aff4a28 100644
--- a/trap.c
+++ b/trap.c
@@ -13,6 +13,8 @@ struct gatedesc idt[256];
 extern uint vectors[];  // in vectors.S: array of 256 entry pointers
 struct spinlock tickslock;
 uint ticks;
+struct proc* prevProc;
+int count;
 
 void
 tvinit(void)
@@ -22,7 +24,7 @@ tvinit(void)
   for(i = 0; i < 256; i++)
     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
-  
+
   initlock(&tickslock, "time");
 }
 
@@ -51,6 +53,8 @@ trap(struct trapframe *tf)
     if(cpu->id == 0){
       acquire(&tickslock);
       ticks++;
+      update_time();
+      endtick++;
       wakeup(&ticks);
       release(&tickslock);
     }
@@ -77,7 +81,7 @@ trap(struct trapframe *tf)
             cpu->id, tf->cs, tf->eip);
     lapiceoi();
     break;
-   
+
   //PAGEBREAK: 13
   default:
     if(proc == 0 || (tf->cs&3) == 0){
@@ -89,21 +93,30 @@ trap(struct trapframe *tf)
     // In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
-            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
             rcr2());
     proc->killed = 1;
   }
 
   // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running 
+  // (If it is still executing in the kernel, let it keep running
   // until it gets to the regular system call return.)
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
 
-  // Force process to give up CPU on clock tick.
-  // If interrupts were on while locks held, would need to check nlock.
-  if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER)
-    yield();
+  #ifndef FCFS
+    if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER){
+      if (prevProc != proc){
+        prevProc = proc;
+        count=0;
+      } else {
+        count++;
+      }
+      if (count == 5){
+        yield();
+      }
+    }
+  #endif
 
   // Check if the process has been killed since we yielded
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
diff --git a/user.h b/user.h
index f45b8d5..580010f 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int wait_stat(int *wtime, int *rtime, int *iotime, int* status);
 
 // ulib.c
 int stat(char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..6f57eba 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(wait_stat)
-- 
2.17.0.windows.1

